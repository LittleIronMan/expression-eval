{"version":3,"file":"expression-eval.js","sources":["../index.ts"],"sourcesContent":["import jsep from 'jsep';\r\n\r\n/**\r\n * Evaluation code from JSEP project, under MIT License.\r\n * Copyright (c) 2013 Stephen Oney, http://jsep.from.so/\r\n */\r\n\r\n// Default operator precedence from https://github.com/EricSmekens/jsep/blob/master/src/jsep.js#L55\r\nconst DEFAULT_PRECEDENCE = {\r\n  '||': 1,\r\n  '&&': 2,\r\n  '|': 3,\r\n  '^': 4,\r\n  '&': 5,\r\n  '==': 6,\r\n  '!=': 6,\r\n  '===': 6,\r\n  '!==': 6,\r\n  '<': 7,\r\n  '>': 7,\r\n  '<=': 7,\r\n  '>=': 7,\r\n  '<<': 8,\r\n  '>>': 8,\r\n  '>>>': 8,\r\n  '+': 9,\r\n  '-': 9,\r\n  '*': 10,\r\n  '/': 10,\r\n  '%': 10\r\n};\r\n\r\nconst binops = {\r\n  '||': function (a, b) { return a || b; },\r\n  '&&': function (a, b) { return a && b; },\r\n  '|': function (a, b) { return a | b; },\r\n  '^': function (a, b) { return a ^ b; },\r\n  '&': function (a, b) { return a & b; },\r\n  '==': function (a, b) { return a == b; }, // jshint ignore:line\r\n  '!=': function (a, b) { return a != b; }, // jshint ignore:line\r\n  '===': function (a, b) { return a === b; },\r\n  '!==': function (a, b) { return a !== b; },\r\n  '<': function (a, b) { return a < b; },\r\n  '>': function (a, b) { return a > b; },\r\n  '<=': function (a, b) { return a <= b; },\r\n  '>=': function (a, b) { return a >= b; },\r\n  '<<': function (a, b) { return a << b; },\r\n  '>>': function (a, b) { return a >> b; },\r\n  '>>>': function (a, b) { return a >>> b; },\r\n  '+': function (a, b) { return a + b; },\r\n  '-': function (a, b) { return a - b; },\r\n  '*': function (a, b) { return a * b; },\r\n  '/': function (a, b) { return a / b; },\r\n  '%': function (a, b) { return a % b; }\r\n};\r\n\r\nconst unops = {\r\n  '-': function (a) { return -a; },\r\n  '+': function (a) { return +a; },\r\n  '~': function (a) { return ~a; },\r\n  '!': function (a) { return !a; },\r\n};\r\n\r\ndeclare type operand = number | string;\r\ndeclare type unaryCallback = (a: operand) => operand;\r\ndeclare type binaryCallback = (a: operand, b: operand) => operand;\r\n\r\ntype AnyExpression = jsep.ArrayExpression\r\n  | jsep.BinaryExpression\r\n  | jsep.MemberExpression\r\n  | jsep.CallExpression\r\n  | jsep.ConditionalExpression\r\n  | jsep.Identifier\r\n  | jsep.Literal\r\n  | jsep.LogicalExpression\r\n  | jsep.ThisExpression\r\n  | jsep.UnaryExpression;\r\n\r\nfunction evaluateArray(list, context) {\r\n  return list.map(function (v) { return evaluate(v, context); });\r\n}\r\n\r\nasync function evaluateArrayAsync(list, context) {\r\n  const res = await Promise.all(list.map((v) => evalAsync(v, context)));\r\n  return res;\r\n}\r\n\r\nfunction evaluateMember(node: jsep.MemberExpression, context: object) {\r\n  const object = evaluate(node.object, context);\r\n  let key: string;\r\n  if (node.computed) {\r\n    key = evaluate(node.property, context);\r\n  } else {\r\n    key = (node.property as jsep.Identifier).name;\r\n  }\r\n  if (/^__proto__|prototype|constructor$/.test(key)) {\r\n    throw Error(\"prototype access detected\");\r\n  }\r\n  return [object, object[key]];\r\n}\r\n\r\nasync function evaluateMemberAsync(node: jsep.MemberExpression, context: object) {\r\n  const object = await evalAsync(node.object, context);\r\n  let key: string;\r\n  if (node.computed) {\r\n    key = await evalAsync(node.property, context);\r\n  } else {\r\n    key = (node.property as jsep.Identifier).name;\r\n  }\r\n  if (/^__proto__|prototype|constructor$/.test(key)) {\r\n    throw Error(\"prototype access detected\");\r\n  }\r\n  return [object, object[key]];\r\n}\r\n\r\nfunction evaluate(_node: jsep.Expression, context: object) {\r\n\r\n  const node = _node as AnyExpression;\r\n\r\n  switch (node.type) {\r\n\r\n    case 'ArrayExpression':\r\n      return evaluateArray(node.elements, context);\r\n\r\n    case 'BinaryExpression':\r\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\r\n\r\n    case 'CallExpression':\r\n      let caller, fn, assign;\r\n      if (node.callee.type === 'MemberExpression') {\r\n        assign = evaluateMember(node.callee as jsep.MemberExpression, context);\r\n        caller = assign[0];\r\n        fn = assign[1];\r\n      } else {\r\n        fn = evaluate(node.callee, context);\r\n      }\r\n      if (typeof fn !== 'function') { return undefined; }\r\n      return fn.apply(caller, evaluateArray(node.arguments, context));\r\n\r\n    case 'ConditionalExpression':\r\n      return evaluate(node.test, context)\r\n        ? evaluate(node.consequent, context)\r\n        : evaluate(node.alternate, context);\r\n\r\n    case 'Identifier':\r\n      return context[node.name];\r\n\r\n    case 'Literal':\r\n      return node.value;\r\n\r\n    case 'LogicalExpression':\r\n      if (node.operator === '||') {\r\n        return evaluate(node.left, context) || evaluate(node.right, context);\r\n      } else if (node.operator === '&&') {\r\n        return evaluate(node.left, context) && evaluate(node.right, context);\r\n      }\r\n      return binops[node.operator](evaluate(node.left, context), evaluate(node.right, context));\r\n\r\n    case 'MemberExpression':\r\n      return evaluateMember(node, context)[1];\r\n\r\n    case 'ThisExpression':\r\n      return context;\r\n\r\n    case 'UnaryExpression':\r\n      return unops[node.operator](evaluate(node.argument, context));\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n\r\n}\r\n\r\nasync function evalAsync(_node: jsep.Expression, context: object) {\r\n\r\n  const node = _node as AnyExpression;\r\n\r\n  // Brackets used for some case blocks here, to avoid edge cases related to variable hoisting.\r\n  // See: https://stackoverflow.com/questions/57759348/const-and-let-variable-shadowing-in-a-switch-statement\r\n  switch (node.type) {\r\n\r\n    case 'ArrayExpression':\r\n      return await evaluateArrayAsync(node.elements, context);\r\n\r\n    case 'BinaryExpression': {\r\n      const [left, right] = await Promise.all([\r\n        evalAsync(node.left, context),\r\n        evalAsync(node.right, context)\r\n      ]);\r\n      return binops[node.operator](left, right);\r\n    }\r\n\r\n    case 'CallExpression': {\r\n      let caller, fn, assign;\r\n      if (node.callee.type === 'MemberExpression') {\r\n        assign = await evaluateMemberAsync(node.callee as jsep.MemberExpression, context);\r\n        caller = assign[0];\r\n        fn = assign[1];\r\n      } else {\r\n        fn = await evalAsync(node.callee, context);\r\n      }\r\n      if (typeof fn !== 'function') {\r\n        return undefined;\r\n      }\r\n      return await fn.apply(\r\n        caller,\r\n        await evaluateArrayAsync(node.arguments, context)\r\n      );\r\n    }\r\n\r\n    case 'ConditionalExpression':\r\n      return (await evalAsync(node.test, context))\r\n        ? await evalAsync(node.consequent, context)\r\n        : await evalAsync(node.alternate, context);\r\n\r\n    case 'Identifier':\r\n      return context[node.name];\r\n\r\n    case 'Literal':\r\n      return node.value;\r\n\r\n    case 'LogicalExpression': {\r\n      if (node.operator === '||') {\r\n        return (\r\n          (await evalAsync(node.left, context)) ||\r\n          (await evalAsync(node.right, context))\r\n        );\r\n      } else if (node.operator === '&&') {\r\n        return (\r\n          (await evalAsync(node.left, context)) &&\r\n          (await evalAsync(node.right, context))\r\n        );\r\n      }\r\n\r\n      const [left, right] = await Promise.all([\r\n        evalAsync(node.left, context),\r\n        evalAsync(node.right, context)\r\n      ]);\r\n\r\n      return binops[node.operator](left, right);\r\n    }\r\n\r\n    case 'MemberExpression':\r\n      return (await evaluateMemberAsync(node, context))[1];\r\n\r\n    case 'ThisExpression':\r\n      return context;\r\n\r\n    case 'UnaryExpression':\r\n      return unops[node.operator](await evalAsync(node.argument, context));\r\n\r\n    default:\r\n      return undefined;\r\n  }\r\n}\r\n\r\nfunction compile(expression: string | jsep.Expression): (context: object) => any {\r\n  return evaluate.bind(null, jsep(expression));\r\n}\r\n\r\nfunction compileAsync(expression: string | jsep.Expression): (context: object) => Promise<any> {\r\n  return evalAsync.bind(null, jsep(expression));\r\n}\r\n\r\n// Added functions to inject Custom Unary Operators (and override existing ones)\r\nfunction addUnaryOp(operator: string, _function: unaryCallback): void {\r\n  jsep.addUnaryOp(operator);\r\n  unops[operator] = _function;\r\n}\r\n\r\n// Added functions to inject Custom Binary Operators (and override existing ones)\r\nfunction addBinaryOp(operator: string, precedence_or_fn: number | binaryCallback, _function: binaryCallback): void {\r\n  if (_function) {\r\n    jsep.addBinaryOp(operator, precedence_or_fn as number);\r\n    binops[operator] = _function;\r\n  } else {\r\n    jsep.addBinaryOp(operator, DEFAULT_PRECEDENCE[operator] || 1);\r\n    binops[operator] = precedence_or_fn;\r\n  }\r\n}\r\n\r\nexport {\r\n  jsep as parse,\r\n  evaluate as eval,\r\n  evalAsync,\r\n  compile,\r\n  compileAsync,\r\n  addUnaryOp,\r\n  addBinaryOp\r\n};\r\n"],"names":["evalAsync","_node","context","node","type","evaluateArrayAsync","elements","Promise","all","left","right","binops","operator","caller","fn","assign","_fn","apply","arguments","callee","evaluateMemberAsync","test","consequent","alternate","name","value","unops","argument","undefined","object","key","Error","computed","property","list","map","v","DEFAULT_PRECEDENCE","||","&&","|","^","&","==","!=","===","!==","<",">","<=",">=","<<",">>",">>>","+","-","*","/","%","a","b","~","!","evaluateArray","evaluate","evaluateMember","precedence_or_fn","_function","jsep","addBinaryOp","addUnaryOp","expression","bind"],"mappings":"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"}